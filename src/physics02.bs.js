// Generated by BUCKLESCRIPT VERSION 1.10.3, PLEASE EDIT WITH CARE
'use strict';

var Curry                   = require("bs-platform/lib/js/curry.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function pass() {
  throw [
        Caml_builtin_exceptions.failure,
        "pass"
      ];
}

function ashDisplacement(t) {
  return 2 * Math.sin(t);
}

function derivative() {
  throw [
        Caml_builtin_exceptions.failure,
        "pass"
      ];
}

function velocityFromDisp() {
  throw [
        Caml_builtin_exceptions.failure,
        "pass"
      ];
}

function accelFromVeloc() {
  throw [
        Caml_builtin_exceptions.failure,
        "pass"
      ];
}

function integral(_, _$1) {
  throw [
        Caml_builtin_exceptions.failure,
        "pass"
      ];
}

function defIntegral(_, _$1, _$2) {
  throw [
        Caml_builtin_exceptions.failure,
        "pass"
      ];
}

function dispFromVelocity(_, _$1) {
  throw [
        Caml_builtin_exceptions.failure,
        "pass"
      ];
}

function velocityFromAccel(_, _$1) {
  throw [
        Caml_builtin_exceptions.failure,
        "pass"
      ];
}

function netDisplacement(d1, d2) {
  return d2 - d1;
}

function netDisplacementFromVelocity(_, _$1, _$2) {
  throw [
        Caml_builtin_exceptions.failure,
        "pass"
      ];
}

function absF(f, x) {
  return Math.abs(Curry._1(f, x));
}

function totalDistance(_, _$1, _$2) {
  throw [
        Caml_builtin_exceptions.failure,
        "pass"
      ];
}

function totalDistanceFromDisp(_, _$1, _$2) {
  throw [
        Caml_builtin_exceptions.failure,
        "pass"
      ];
}

function averageVelocity(d, t1, t2) {
  var disp = totalDistanceFromDisp(d, t1, t2);
  return disp / (t2 - t1);
}

exports.pass                        = pass;
exports.ashDisplacement             = ashDisplacement;
exports.derivative                  = derivative;
exports.velocityFromDisp            = velocityFromDisp;
exports.accelFromVeloc              = accelFromVeloc;
exports.integral                    = integral;
exports.defIntegral                 = defIntegral;
exports.dispFromVelocity            = dispFromVelocity;
exports.velocityFromAccel           = velocityFromAccel;
exports.netDisplacement             = netDisplacement;
exports.netDisplacementFromVelocity = netDisplacementFromVelocity;
exports.absF                        = absF;
exports.totalDistance               = totalDistance;
exports.totalDistanceFromDisp       = totalDistanceFromDisp;
exports.averageVelocity             = averageVelocity;
/* No side effect */
